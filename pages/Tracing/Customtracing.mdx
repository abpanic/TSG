# How to include logging in your Custom App.
Example below is in C# but the same logic applies in other programming languages

## Popular Logging Frameworks

Several excellent logging frameworks are available for C# applications:

- **NLog**: A flexible and mature logging library with support for various targets (files, databases, consoles, etc.) and advanced features like structured logging. https://nlog-project.org/
- **Serilog**: Designed with structured logging at its core. Events are enriched with properties for powerful filtering and searching within your logs. https://serilog.net/
- **log4net**: A well-established port of the popular Apache log4j framework, offering various configuration options and log appenders. https://logging.apache.org/log4net/

## Microsoft's Built-in Logging

C# also provides its own built-in logging capabilities using the `Microsoft.Extensions.Logging` namespace. This is a good option for simpler applications, or if you want to minimize external dependencies.

## How to Include Logging

Let's illustrate how to add logging with a popular framework like NLog:

**1. Installation:**
Install the NLog NuGet package in your project:

```PowerShell
Install-Package NLog -Version <latest_version>
```

**2. Configuration:**
Create an NLog configuration file (typically named `NLog.config`) in your project's root directory:

```XML
<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <targets>
        <target name="file" xsi:type="File" fileName="${basedir}/logs/applog.txt" />
    </targets>

    <rules>
        <logger name="*" minlevel="Debug" writeTo="file" />
    </rules>
</nlog>
```

This configuration defines a file target to write logs to `applog.txt` and instructs NLog to capture logs with the 'Debug' level and higher.

**3. Usage:**
In your C# code, obtain an ILogger instance and use it to log messages:

```C#
using NLog;

class MyClass
{
    private static readonly ILogger logger = LogManager.GetCurrentClassLogger();

    public void DoSomething()
    {
        logger.Debug("Starting the process...");
        try 
        {
            // Code that might have errors
            logger.Info("Process completed successfully"); 
        }
        catch (Exception ex)
        {
            logger.Error(ex, "An error occurred");
        }
    }
}
```

## Best Practices

- **Log Levels**: Utilize log levels (Trace, Debug, Information, Warning, Error, Critical) to categorize messages appropriately. This aids in filtering and analysis.
- **Contextual Information**: Include relevant details like timestamps, user IDs, method names, and exception data to make logs more informative for debugging.
- **Structured Logging**: Consider a framework like Serilog for structured logging. This allows you to query your logs as if they were a database.
- **Log Rotation**: Employ log rotation strategies to prevent log files from becoming excessively large.
- **Centralized Logging**: For larger systems, explore centralized log aggregation tools like Elasticsearch/Kibana to manage logs from multiple sources.

## Here's how we can approach this using NLog for our logging framework in a sample custom app that connects to D365 CE.

**1. Set up the Project**

Create a new C# console or Windows application.
Install the following NuGet packages:
* `NLog`
* `Microsoft.CrmSdk.CoreAssemblies` (for Dynamics 365 CE interactions)
**2. NLog Configuration** (`NLog.config`)

```XML
<?xml version="1.0" encoding="utf-8" ?>
<nlog xmlns="http://www.nlog-project.org/schemas/NLog.xsd"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

    <targets>
        <target name="file" xsi:type="File" fileName="${basedir}/logs/d365app.log" />
    </targets>

    <rules>
        <logger name="*" minlevel="Trace" writeTo="file" />
    </rules>
</nlog>
```

**3. C# Code**

```C#
using NLog;
using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;

namespace D365CE_WhoAmI
{
    class Program
    {
        private static readonly ILogger logger = LogManager.GetCurrentClassLogger();

        static void Main(string[] args)
        {
            try
            {
                string connectionString = "Your D365 CE Connection String";
                IOrganizationService service = ConnectToCrm(connectionString);

                if (service != null)
                {
                    Guid userId = ((WhoAmIResponse)service.Execute(new WhoAmIRequest())).UserId;
                    logger.Info($"WhoAmI call successful. User ID: {userId}");
                } 
                else
                {
                    logger.Error("Failed to connect to Dynamics 365 CE");
                }
            }
            catch (Exception ex)
            {
                logger.Error(ex, "An error occurred during the WhoAmI process");
            }
        }

        private static IOrganizationService ConnectToCrm(string connectionString)
        {
            logger.Debug("Connecting to Dynamics 365 CE...");
            // Implement your Dynamics 365 CE connection logic using connectionString
            // ...
        }
    }
}
```

**Explanation**

- **NLog Configuration:** The provided `NLog.config` logs all levels (Trace and above) to the file `d365app.log`.
- **Logging in Code:**
- We get an `ILogger` instance for our class.
- Logging is used within the `ConnectToCrm` function to log connection attempts.
- Success or failure of the WhoAmI call is logged.
- Exceptions are caught and logged with detailed error messages.
**Important:**

Replace `"Your D365 CE Connection String"` with your actual Dynamics 365 CE connection string.
Ensure the NLog.config file is copied to the output directory of your application.
**Benefits of Logging**

With this logging setup, you will have a log file that records:

- Attempts to connect to Dynamics 365 CE.
- The outcome of the WhoAmI request.
- Any specific errors that might occur during the process.